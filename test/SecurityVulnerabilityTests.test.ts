import { expect } from "chai";

describe("MultiSigWallet Security Vulnerability Tests", function () {
  let multiSigWallet: any;
  let mockTarget: any;
  let maliciousContract: any;
  let owner1: any, owner2: any, owner3: any;
  let attacker: any;
  let ethers: any;

describe("MultiSigWallet Security Vulnerability Tests", function () {
  let multiSigWallet: any;
  let mockTarget: any;
  let maliciousContract: any;
  let owner1: any, owner2: any, owner3: any;
  let attacker: any;

  beforeEach(async function () {
    // 获取测试账户
    [owner1, owner2, owner3, attacker] = await ethers.getSigners();

    // 设置多签名钱包参数
    const owners = [owner1.address, owner2.address, owner3.address];
    const required = 2;

    // 部署MultiSigWallet合约
    const MultiSigWallet = await ethers.getContractFactory("MultiSigWallet");
    multiSigWallet = await MultiSigWallet.deploy(owners, required);

    // 部署测试用的MockTarget合约
    const MockTarget = await ethers.getContractFactory("MockTarget");
    mockTarget = await MockTarget.deploy();

    // 部署恶意合约用于测试
    const MaliciousContract = await ethers.getContractFactory("MaliciousContract");
    maliciousContract = await MaliciousContract.deploy();

    // 为钱包充值
    await owner1.sendTransaction({
      to: multiSigWallet.target,
      value: ethers.parseEther("10.0")
    });
  });

  describe("Reentrancy Attack Protection", function () {
    it("Should prevent reentrancy attacks on executeTransaction", async function () {
      // 设置恶意合约的目标钱包
      await maliciousContract.setTarget(multiSigWallet.target);

      // 创建一个调用恶意合约的交易
      const maliciousData = maliciousContract.interface.encodeFunctionData("attack");
      
      await multiSigWallet.connect(owner1).submitTransaction(
        maliciousContract.target,
        ethers.parseEther("1.0"),
        maliciousData
      );

      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 验证重入攻击被阻止
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.false; // 交易应该失败
    });

    it("Should prevent reentrancy in batch operations", async function () {
      // 设置恶意合约
      await maliciousContract.setTarget(multiSigWallet.target);

      // 创建包含恶意调用的批量交易
      const targets = [maliciousContract.target, mockTarget.target];
      const values = [ethers.parseEther("1.0"), 0];
      const dataArray = [
        maliciousContract.interface.encodeFunctionData("attack"),
        mockTarget.interface.encodeFunctionData("setValue", [42])
      ];

      await multiSigWallet.connect(owner1).batchSubmit(targets, values, dataArray);

      // 尝试批量确认（应该部分失败）
      await multiSigWallet.connect(owner2).batchConfirm([0, 1]);

      // 验证恶意交易失败，正常交易成功
      const [, , , executed1] = await multiSigWallet.getTransaction(0);
      const [, , , executed2] = await multiSigWallet.getTransaction(1);
      
      expect(executed1).to.be.false; // 恶意交易失败
      expect(executed2).to.be.true;  // 正常交易成功
    });
  });

  describe("Access Control Vulnerabilities", function () {
    it("Should prevent unauthorized transaction submission", async function () {
      try {
        await multiSigWallet.connect(attacker).submitTransaction(
          mockTarget.target,
          0,
          "0x"
        );
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("not owner");
      }
    });

    it("Should prevent unauthorized confirmation", async function () {
      // 所有者提交交易
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );

      // 非所有者尝试确认
      try {
        await multiSigWallet.connect(attacker).confirmTransaction(0);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect.error.message).to.include("not owner");
      }
    });

    it("Should prevent unauthorized owner management", async function () {
      // 非所有者尝试添加所有者
      try {
        await multiSigWallet.connect(attacker).addOwner(attacker.address);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("only wallet");
      }

      // 非所有者尝试移除所有者
      try {
        await multiSigWallet.connect(attacker).removeOwner(owner1.address);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("only wallet");
      }
    });

    it("Should prevent unauthorized emergency functions", async function () {
      // 非所有者尝试紧急暂停
      try {
        await multiSigWallet.connect(attacker).emergencyPause();
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("only wallet");
      }
    });

    it("Should prevent batch operations by non-owners", async function () {
      try {
        await multiSigWallet.connect(attacker).batchConfirm([0]);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("not owner");
      }

      try {
        await multiSigWallet.connect(attacker).batchSubmit([mockTarget.target], [0], ["0x"]);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("not owner");
      }
    });
  });

  describe("Integer Overflow/Underflow Protection", function () {
    it("Should handle transaction count overflow protection", async function () {
      // 这个测试验证交易计数器不会溢出
      // 在实际场景中，达到uint256最大值是不现实的，但我们测试边界行为
      
      const currentCount = await multiSigWallet.getTransactionCount();
      expect(currentCount).to.be.lessThan(ethers.MaxUint256);
    });

    it("Should handle confirmation count boundaries", async function () {
      // 测试确认计数的边界
      await multiSigWallet.connect(owner1).submitTransaction(mockTarget.target, 0, "0x");
      
      const initialConfirmations = await multiSigWallet.getConfirmationCount(0);
      expect(initialConfirmations).to.equal(1);

      await multiSigWallet.connect(owner2).confirmTransaction(0);
      const finalConfirmations = await multiSigWallet.getConfirmationCount(0);
      expect(finalConfirmations).to.equal(2);
    });

    it("Should prevent value overflow in uint96", async function () {
      const maxUint96 = "79228162514264337593543950335";
      const overMaxValue = "79228162514264337593543950336";

      // 最大值应该成功
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        maxUint96,
        "0x"
      );

      // 超过最大值应该失败
      try {
        await multiSigWallet.connect(owner1).submitTransaction(
          mockTarget.target,
          overMaxValue,
          "0x"
        );
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("value exceeds maximum");
      }
    });
  });

  describe("Front-Running Protection", function () {
    it("Should handle transaction ordering attacks", async function () {
      // 模拟前置运行攻击场景
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        ethers.parseEther("1.0"),
        "0x"
      );

      // 攻击者尝试在确认之前插入自己的交易
      await multiSigWallet.connect(owner1).submitTransaction(
        attacker.address,
        ethers.parseEther("2.0"),
        "0x"
      );

      // 正常确认流程
      await multiSigWallet.connect(owner2).confirmTransaction(0);
      await multiSigWallet.connect(owner2).confirmTransaction(1);

      // 验证交易按提交顺序执行
      const [, , , executed1] = await multiSigWallet.getTransaction(0);
      const [, , , executed2] = await multiSigWallet.getTransaction(1);
      
      expect(executed1).to.be.true;
      expect(executed2).to.be.true;
    });

    it("Should prevent confirmation manipulation", async function () {
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );

      // 第一次确认
      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 尝试重复确认（应该失败）
      try {
        await multiSigWallet.connect(owner2).confirmTransaction(0);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("already confirmed");
      }

      // 撤销确认
      await multiSigWallet.connect(owner2).revokeConfirmation(0);

      // 重新确认应该成功
      await multiSigWallet.connect(owner2).confirmTransaction(0);
      
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.true;
    });
  });

  describe("Denial of Service (DoS) Protection", function () {
    it("Should handle gas limit attacks in batch operations", async function () {
      // 创建大量交易但不超过限制
      const maxBatchSize = 20;
      const targets = Array(maxBatchSize).fill(mockTarget.target);
      const values = Array(maxBatchSize).fill(0);
      const dataArray = Array(maxBatchSize).fill("0x");

      // 应该成功
      await multiSigWallet.connect(owner1).batchSubmit(targets, values, dataArray);

      // 尝试超过限制
      const oversizedTargets = Array(21).fill(mockTarget.target);
      const oversizedValues = Array(21).fill(0);
      const oversizedDataArray = Array(21).fill("0x");

      try {
        await multiSigWallet.connect(owner1).batchSubmit(oversizedTargets, oversizedValues, oversizedDataArray);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("too many transactions");
      }
    });

    it("Should prevent empty batch operations DoS", async function () {
      try {
        await multiSigWallet.connect(owner1).batchConfirm([]);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("empty transaction list");
      }
    });

    it("Should handle failed external calls gracefully", async function () {
      // 创建一个会失败的外部调用
      const failingData = mockTarget.interface.encodeFunctionData("failingFunction");
      
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        failingData
      );

      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 验证失败的调用不会阻止钱包操作
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.false;

      // 钱包应该仍然可以正常操作
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );
      expect(await multiSigWallet.getTransactionCount()).to.equal(2);
    });
  });

  describe("Signature Replay Protection", function () {
    it("Should prevent transaction replay", async function () {
      // 提交并执行一个交易
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );
      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 验证交易已执行
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.true;

      // 尝试重新执行相同的交易（应该失败）
      try {
        await multiSigWallet.connect(owner1).executeTransaction(0);
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("already executed");
      }
    });

    it("Should prevent confirmation replay after revocation", async function () {
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );

      // 确认然后撤销
      await multiSigWallet.connect(owner2).confirmTransaction(0);
      await multiSigWallet.connect(owner2).revokeConfirmation(0);

      // 验证确认已撤销
      const isConfirmed = await multiSigWallet.confirmations(0, owner2.address);
      expect(isConfirmed).to.be.false;

      // 重新确认应该成功
      await multiSigWallet.connect(owner2).confirmTransaction(0);
      
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.true;
    });
  });

  describe("State Manipulation Attacks", function () {
    it("Should prevent unauthorized state changes through external calls", async function () {
      // 尝试通过外部调用修改钱包状态
      const maliciousData = multiSigWallet.interface.encodeFunctionData("addOwner", [attacker.address]);
      
      await multiSigWallet.connect(owner1).submitTransaction(
        multiSigWallet.target,
        0,
        maliciousData
      );

      // 这应该需要多签确认，单个所有者无法直接修改
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.false; // 需要第二个确认

      // 验证攻击者未被添加为所有者
      const owners = await multiSigWallet.getOwners();
      expect(owners).to.not.include(attacker.address);
    });

    it("Should prevent paused state manipulation", async function () {
      // 暂停钱包
      const pauseData = multiSigWallet.interface.encodeFunctionData("emergencyPause");
      await multiSigWallet.connect(owner1).submitTransaction(
        multiSigWallet.target,
        0,
        pauseData
      );
      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 验证钱包已暂停
      expect(await multiSigWallet.paused()).to.be.true;

      // 尝试在暂停状态下执行操作
      try {
        await multiSigWallet.connect(owner1).submitTransaction(
          mockTarget.target,
          0,
          "0x"
        );
        expect.fail("Should have thrown");
      } catch (error: any) {
        expect(error.message).to.include("paused");
      }
    });
  });

  describe("Economic Attacks", function () {
    it("Should handle insufficient balance attacks", async function () {
      // 尝试发送超过钱包余额的金额
      const walletBalance = await ethers.provider.getBalance(multiSigWallet.target);
      const excessiveAmount = walletBalance + ethers.parseEther("1.0");

      await multiSigWallet.connect(owner1).submitTransaction(
        attacker.address,
        excessiveAmount,
        "0x"
      );

      await multiSigWallet.connect(owner2).confirmTransaction(0);

      // 验证交易失败
      const [, , , executed] = await multiSigWallet.getTransaction(0);
      expect(executed).to.be.false;

      // 验证钱包余额未受影响
      const finalBalance = await ethers.provider.getBalance(multiSigWallet.target);
      expect(finalBalance).to.equal(walletBalance);
    });

    it("Should prevent gas griefing attacks", async function () {
      // 创建一个消耗大量gas的交易
      const gasGriefingData = mockTarget.interface.encodeFunctionData("gasGriefing");
      
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        gasGriefingData
      );

      // 确认交易（可能会因gas不足而失败）
      try {
        await multiSigWallet.connect(owner2).confirmTransaction(0);
      } catch (error: any) {
        // 预期可能因gas不足而失败
        expect(error.message).to.include("gas");
      }

      // 钱包应该仍然可以正常操作
      await multiSigWallet.connect(owner1).submitTransaction(
        mockTarget.target,
        0,
        "0x"
      );
      expect(await multiSigWallet.getTransactionCount()).to.equal(2);
    });
  });
});
